<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Elastic Grid Network</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #ffffff;
            overflow: hidden;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        canvas {
            cursor: grab;
        }
        
        canvas:active {
            cursor: grabbing;
        }
    </style>
</head>
<body>
    <canvas id="gridCanvas"></canvas>
    
    <script>
        const canvas = document.getElementById('gridCanvas');
        const ctx = canvas.getContext('2d');
        
        // Set canvas size
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        // Grid configuration
        const GRID_SIZE = 25;
        const SPACING = 30;
        const LETTERS = ['P', 'I', 'N', 'H', 'A', 'U', 'S'];
        const FONT_SIZE = 12;
        const DAMPING = 0.92;
        const ATTRACTION_STRENGTH = 0.12;
        const INFLUENCE_RADIUS = 90;
        
        // Ripple class
        class Ripple {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 0;
                this.maxRadius = 300;
                this.speed = 4;
                this.alpha = 1;
            }
            
            update() {
                this.radius += this.speed;
                this.alpha = Math.max(0, 1 - (this.radius / this.maxRadius));
                return this.radius < this.maxRadius;
            }
            
            getInfluenceAt(x, y) {
                const distance = Math.sqrt((x - this.x) ** 2 + (y - this.y) ** 2);
                const rippleEdge = this.radius;
                const rippleWidth = 50;
                
                if (distance >= rippleEdge - rippleWidth && distance <= rippleEdge + rippleWidth) {
                    const distanceFromEdge = Math.abs(distance - rippleEdge);
                    const influence = (1 - distanceFromEdge / rippleWidth) * this.alpha;
                    return Math.max(0, influence);
                }
                return 0;
            }
        }
        
        // Node class
        class Node {
            constructor(x, y, originalX, originalY, letter) {
                this.x = x;
                this.y = y;
                this.originalX = originalX;
                this.originalY = originalY;
                this.vx = 0;
                this.vy = 0;
                this.letter = letter;
                this.connections = [];
                this.isDragging = false;
                this.energy = 0;
                this.rippleInfluence = 0;
            }
            
            update(mouseX, mouseY, prevMouseX, prevMouseY, isMouseDown, mouseVelocity, time, ripples) {
                // Calculate ripple influence
                this.rippleInfluence = 0;
                for (let ripple of ripples) {
                    this.rippleInfluence = Math.max(this.rippleInfluence, ripple.getInfluenceAt(this.x, this.y));
                }
                
                // Subtle breathing effect (always active)
                const breathingPhase = time * 0.001 + this.originalX * 0.005 + this.originalY * 0.005;
                const breathingIntensity = Math.sin(breathingPhase) * 0.5 + 0.5;
                this.breathingScale = 1 + breathingIntensity * 0.3;
                
                // Calculate dynamic influence radius based on velocity
                const dynamicInfluenceRadius = INFLUENCE_RADIUS * (1 + mouseVelocity * 0.01);
                
                // Check if mouse is within influence radius
                const distanceToMouse = Math.sqrt((mouseX - this.x) ** 2 + (mouseY - this.y) ** 2);
                
                if (isMouseDown && distanceToMouse <= dynamicInfluenceRadius) {
                    // Calculate drag direction from mouse movement
                    const dragDirX = mouseX - prevMouseX;
                    const dragDirY = mouseY - prevMouseY;
                    const dragMagnitude = Math.sqrt(dragDirX * dragDirX + dragDirY * dragDirY);
                    
                    if (dragMagnitude > 0) {
                        // Apply drag force in the direction of mouse movement
                        const influence = 1 - (distanceToMouse / dynamicInfluenceRadius);
                        const forceStrength = influence * (0.5 + mouseVelocity * 0.02);
                        
                        this.vx += (dragDirX / dragMagnitude) * forceStrength;
                        this.vy += (dragDirY / dragMagnitude) * forceStrength;
                    }
                }
                
                // Spring force back to original position
                const dx = this.originalX - this.x;
                const dy = this.originalY - this.y;
                this.vx += dx * ATTRACTION_STRENGTH;
                this.vy += dy * ATTRACTION_STRENGTH;
                
                // Apply velocity
                this.x += this.vx;
                this.y += this.vy;
                
                // Damping
                this.vx *= DAMPING;
                this.vy *= DAMPING;
                
                // Calculate energy for visual effects
                this.energy = Math.sqrt(this.vx * this.vx + this.vy * this.vy) * 10;
                this.energy = Math.min(this.energy, 1);
            }
            
            draw() {
                // Apply breathing scale to font size
                const scaledFontSize = FONT_SIZE * (this.breathingScale || 1);
                
                // Determine if this letter should be inverted based on ripple influence
                const isInverted = this.rippleInfluence > 0.1;
                
                if (isInverted) {
                    // White letter (inverted)
                    ctx.fillStyle = `rgba(255, 255, 255, ${0.3 + this.rippleInfluence * 0.7})`;
                } else {
                    // Normal black letter
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                }
                
                ctx.font = `${scaledFontSize}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.letter, this.x, this.y);
            }
            
            isPointInside(px, py) {
                const dx = px - this.x;
                const dy = py - this.y;
                return dx * dx + dy * dy <= 10 * 10;
            }
        }
        
        // Create grid - fill entire space
        const nodes = [];
        const cols = Math.ceil(canvas.width / SPACING) + 2;
        const rows = Math.ceil(canvas.height / SPACING) + 2;
        
        for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
                const x = col * SPACING;
                const y = row * SPACING;
                const letterIndex = (row * cols + col) % LETTERS.length;
                const letter = LETTERS[letterIndex];
                nodes.push(new Node(x, y, x, y, letter));
            }
        }
        
        // Create connections - no longer needed but keeping structure
        for (let node of nodes) {
            node.connections = [];
        }
        
        // Mouse interaction
        let mouseX = 0;
        let mouseY = 0;
        let prevMouseX = 0;
        let prevMouseY = 0;
        let isMouseDown = false;
        let draggedNode = null;
        let mouseVelocity = 0;
        let ripples = [];
        
        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
        }
        
        // Mouse events
        canvas.addEventListener('mousedown', (e) => {
            const pos = getMousePos(e);
            mouseX = pos.x;
            mouseY = pos.y;
            isMouseDown = true;
            
            // Create a new ripple at click position
            ripples.push(new Ripple(mouseX, mouseY));
        });
        
        canvas.addEventListener('mousemove', (e) => {
            prevMouseX = mouseX;
            prevMouseY = mouseY;
            
            const pos = getMousePos(e);
            mouseX = pos.x;
            mouseY = pos.y;
            
            // Calculate mouse velocity
            const deltaX = mouseX - prevMouseX;
            const deltaY = mouseY - prevMouseY;
            mouseVelocity = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        });
        
        canvas.addEventListener('mouseup', () => {
            isMouseDown = false;
            draggedNode = null;
        });
        
        // Touch events
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            mouseX = touch.clientX - rect.left;
            mouseY = touch.clientY - rect.top;
            isMouseDown = true;
            
            // Create a new ripple at touch position
            ripples.push(new Ripple(mouseX, mouseY));
        });
        
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            prevMouseX = mouseX;
            prevMouseY = mouseY;
            
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            mouseX = touch.clientX - rect.left;
            mouseY = touch.clientY - rect.top;
            
            // Calculate mouse velocity
            const deltaX = mouseX - prevMouseX;
            const deltaY = mouseY - prevMouseY;
            mouseVelocity = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        });
        
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            isMouseDown = false;
            draggedNode = null;
        });
        
        // Animation loop
        function animate() {
            const currentTime = Date.now();
            
            // Calculate overall background inversion based on ripples
            let backgroundInversion = 0;
            for (let ripple of ripples) {
                // Calculate how much of the screen this ripple affects
                const rippleArea = Math.PI * ripple.radius * ripple.radius;
                const screenArea = canvas.width * canvas.height;
                const influence = Math.min(rippleArea / screenArea, 1) * ripple.alpha;
                backgroundInversion = Math.max(backgroundInversion, influence * 0.5);
            }
            
            // Set background color based on inversion
            const bgGray = Math.floor(backgroundInversion * 255);
            canvas.style.backgroundColor = `rgb(${bgGray}, ${bgGray}, ${bgGray})`;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Update and filter ripples
            ripples = ripples.filter(ripple => ripple.update());
            
            // Update nodes
            for (let node of nodes) {
                node.update(mouseX, mouseY, prevMouseX, prevMouseY, isMouseDown, mouseVelocity, currentTime, ripples);
            }
            
            // Draw nodes
            for (let node of nodes) {
                node.draw();
            }
            
            requestAnimationFrame(animate);
        }
        
        // Start animation
        animate();
        
        // Handle window resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            // Recreate grid to fill new space
            nodes.length = 0;
            const cols = Math.ceil(canvas.width / SPACING) + 2;
            const rows = Math.ceil(canvas.height / SPACING) + 2;
            
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const x = col * SPACING;
                    const y = row * SPACING;
                    const letterIndex = (row * cols + col) % LETTERS.length;
                    const letter = LETTERS[letterIndex];
                    nodes.push(new Node(x, y, x, y, letter));
                }
            }
        });
    </script>
</body>
</html>