<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Noise Flow Particle System</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        
        canvas {
            border: none;
            background: #111;
            width: 100%;
            height: 100%;
            display: block;
        }
    </style>
</head>
<body>
    <span id="pauseBtn" style="display:none"></span>
    <canvas id="canvas" width="1600" height="900"></canvas>
    
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        const PARTICLE_COUNT = 10000;
        const MAX_PARTICLE_COUNT = 20000; // Allow second wave (death split) to come in
        const MAX_AGE = 800;
        const NOISE_SCALE = 0.003;
        const FLOW_STRENGTH = 0.1;
        
        let particles = [];
        let spawnLines = [];
        let isPaused = false;
        let mouse = {
            x: 0,
            y: 0,
            isHovering: false
        };
        let time = 0;
        let lastLineGeneration = 0;
        let lineGenerationInterval = 15 * 60; // 15 seconds * 60 fps = 900 frames
        let currentWave = 0;
        
        // Simple noise function (simplified Perlin-like)
        function noise(x, y, z = 0) {
            const X = Math.floor(x) & 255;
            const Y = Math.floor(y) & 255;
            const Z = Math.floor(z) & 255;
            x -= Math.floor(x);
            y -= Math.floor(y);
            z -= Math.floor(z);
            const u = fade(x);
            const v = fade(y);
            const w = fade(z);
            const A = p[X] + Y;
            const AA = p[A] + Z;
            const AB = p[A + 1] + Z;
            const B = p[X + 1] + Y;
            const BA = p[B] + Z;
            const BB = p[B + 1] + Z;
            
            return lerp(w, lerp(v, lerp(u, grad(p[AA], x, y, z),
                                          grad(p[BA], x - 1, y, z)),
                                   lerp(u, grad(p[AB], x, y - 1, z),
                                          grad(p[BB], x - 1, y - 1, z))),
                           lerp(v, lerp(u, grad(p[AA + 1], x, y, z - 1),
                                          grad(p[BA + 1], x - 1, y, z - 1)),
                                   lerp(u, grad(p[AB + 1], x, y - 1, z - 1),
                                          grad(p[BB + 1], x - 1, y - 1, z - 1))));
        }
        
        function fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
        function lerp(t, a, b) { return a + t * (b - a); }
        function grad(hash, x, y, z) {
            const h = hash & 15;
            const u = h < 8 ? x : y;
            const v = h < 4 ? y : h === 12 || h === 14 ? x : z;
            return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
        }
        
        // Permutation table for noise
        const p = new Array(512);
        const permutation = [151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];
        for (let i = 0; i < 256; i++) p[256 + i] = p[i] = permutation[i];
        
        // Generate evenly spaced vertical spawn lines
        function generateSpawnLines() {
            spawnLines = [];
            const numLines = Math.floor(Math.random() * 6) + 4; // 4-9 lines
            const spacing = canvas.width / (numLines + 1);
            
            for (let i = 0; i < numLines; i++) {
                const x = spacing * (i + 1); // Center the lines with even spacing
                spawnLines.push({
                    x: x,
                    direction: Math.random() > 0.5 ? 1 : -1, // 1 for up, -1 for down
                    intensity: Math.random() * 0.8 + 0.3,
                    width: Math.random() * 20 + 5, // Smaller spawn width since lines are transparent
                    color: {
                        r: Math.floor(Math.random() * 100 + 155),
                        g: Math.floor(Math.random() * 100 + 155),
                        b: Math.floor(Math.random() * 100 + 155)
                    }
                });
            }
        }
        
        class Particle {
            constructor(spawnLine, isDeathSplit = false, deathSplitGeneration = 0) {
                this.line = spawnLine;
                this.x = spawnLine.x + (Math.random() - 0.5) * spawnLine.width;
                // Spawn anywhere along the full height of the line
                this.y = Math.random() * canvas.height;
                
                this.vx = 0;
                this.vy = 0;
                this.age = 0;
                this.life = Math.random() * 0.8 + 0.2;
                this.size = Math.random() * 1.5 + 0.5;
                this.baseY = this.y;
                this.baseX = this.x;
                this.hasSplit = false;
                this.isSplitParticle = false;
                this.isDeathSplit = isDeathSplit;
                this.deathSplitGeneration = deathSplitGeneration;
                this.canSecondSplit = false; // Only one of the 8 death split particles can split again
                this.birthWave = currentWave;
            }
            
            split() {
                // Create a new particle at the same position
                if (particles.length < MAX_PARTICLE_COUNT) {
                    const splitParticle = new Particle(this.line);
                    splitParticle.x = this.x;
                    splitParticle.y = this.y;
                    splitParticle.age = 0; // Reset age for split particle
                    splitParticle.life = Math.random() * 0.8 + 0.2; // Reset life for split particle
                    splitParticle.hasSplit = false; // Allow split particle to split again
                    splitParticle.isSplitParticle = true; // Mark as split particle (turns red)
                    
                    // Give the split particle a different velocity direction
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 0.5;
                    splitParticle.vx = Math.cos(angle) * speed;
                    splitParticle.vy = Math.sin(angle) * speed;
                    
                    // Modify this particle's velocity too
                    const angle2 = angle + Math.PI; // Opposite direction
                    this.vx += Math.cos(angle2) * speed;
                    this.vy += Math.sin(angle2) * speed;
                    
                    // Mark this particle as split and as a split particle (turns red)
                    this.isSplitParticle = true;
                    
                    particles.push(splitParticle);
                    
                    // Trigger chain reaction - find nearest particle and make it split
                    this.triggerChainReaction();
                }
            }
            
            // Method to create 8 particles on natural death
            createDeathSplitParticles() {
                if (particles.length + 8 <= MAX_PARTICLE_COUNT) {
                    for (let i = 0; i < 8; i++) {
                        const deathSplitParticle = new Particle(this.line, true, this.deathSplitGeneration + 1);
                        deathSplitParticle.x = this.x;
                        deathSplitParticle.y = this.y;
                        deathSplitParticle.age = 0;
                        deathSplitParticle.life = Math.random() * 0.8 + 0.2;
                        
                        // Only one of the 8 can split again, and only if this is the first generation
                        if (i === 0 && this.deathSplitGeneration === 0) {
                            deathSplitParticle.canSecondSplit = true;
                        }
                        
                        // Give each particle a radial direction
                        const angle = (i / 8) * Math.PI * 2;
                        const speed = 0.5 + Math.random() * 0.5;
                        deathSplitParticle.vx = Math.cos(angle) * speed;
                        deathSplitParticle.vy = Math.sin(angle) * speed;
                        
                        particles.push(deathSplitParticle);
                    }
                }
            }
            
            triggerChainReaction() {
                let nearestParticle = null;
                let minDistance = Infinity;
                const searchRadius = 50; // Only look within this radius
                
                for (let other of particles) {
                    // Only trigger particles that haven't split and can still split (generation < 2)
                    if (other !== this && !other.hasSplit && other.life > 0.1 && other.splitGeneration < 2) {
                        const dx = this.x - other.x;
                        const dy = this.y - other.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < searchRadius && distance < minDistance) {
                            minDistance = distance;
                            nearestParticle = other;
                        }
                    }
                }
                
                // Make the nearest particle split with a slight delay for visual effect
                if (nearestParticle) {
                    setTimeout(() => {
                        if (nearestParticle.life > 0 && !nearestParticle.hasSplit && nearestParticle.splitGeneration < 2) {
                            nearestParticle.hasSplit = true;
                            nearestParticle.split();
                        }
                    }, 50); // 50ms delay for chain reaction effect
                }
            }
            
            update() {
                this.age++;
                
                const ageRatio = Math.min(this.age / MAX_AGE, 1);
                const t = time * 0.01;
                
                // Sample noise field for flow direction
                const nx = this.x * NOISE_SCALE;
                const ny = this.y * NOISE_SCALE;
                const nz = t * 0.5;
                
                // Get flow vectors from noise (expanded range for all directions)
                const flowX = (noise(nx + 300, ny + 500, nz) * 2 - 1) * FLOW_STRENGTH;
                const flowY = (noise(nx + 100, ny + 300, nz) * 2 - 1) * FLOW_STRENGTH;
                
                // Add additional noise samples for more varied directions
                const flowX2 = (noise(nx + 700, ny + 200, nz + 100) * 2 - 1) * FLOW_STRENGTH * 0.5;
                const flowY2 = (noise(nx + 900, ny + 800, nz + 200) * 2 - 1) * FLOW_STRENGTH * 0.5;
                
                // Apply directional bias from spawn line (reduced influence)
                const directionalBias = this.line.direction * 0.1 * this.line.intensity;
                
                // Combine noise flows with directional movement
                this.vx += (flowX + flowX2) * 0.1;
                this.vy += (flowY + flowY2) * 0.1 + (directionalBias * 0.1);
                
                // Apply some damping
                this.vx *= 0.98;
                this.vy *= 0.98;
                
                // Update position
                this.x += this.vx;
                this.y += this.vy;
                
                // Check for mouse hover splitting
                if (!this.hasSplit && this.isMouseHovering()) {
                    this.split();
                    this.hasSplit = true;
                }
                
                // Check for special splitting for death split particles
                if (this.isDeathSplit && this.canSecondSplit && !this.hasSplit && this.life < 0.3) {
                    this.createDeathSplitParticles();
                    this.hasSplit = true;
                }
                
                // Decrease life
                this.life -= 0.001;
                
                // Check if particle should die naturally and split
                if (this.life <= 0 || this.age > MAX_AGE) {
                    // Only create death split particles if this is an original particle (not split from mouse or death split)
                    // And only 1 in 8 particles will split (12.5% chance)
                    if (!this.isSplitParticle && !this.isDeathSplit && Math.random() < 0.125) {
                        this.createDeathSplitParticles();
                    }
                    this.respawn();
                    return;
                }
                
                // Reset particle if it's off screen
                if (this.x < -50 || this.x > canvas.width + 50 ||
                    this.y < -50 || this.y > canvas.height + 50) {
                    this.respawn();
                }
            }
            
            isMouseHovering() {
                const dx = mouse.x - this.x;
                const dy = mouse.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance < (this.size * 3); // Hover radius is 3x particle size
            }
            
            respawn() {
                // Choose a random spawn line
                this.line = spawnLines[Math.floor(Math.random() * spawnLines.length)];
                this.x = this.line.x + (Math.random() - 0.5) * this.line.width;
                // Respawn anywhere along the full height of the line
                this.y = Math.random() * canvas.height;
                this.baseX = this.x;
                this.baseY = this.y;
                this.vx = 0;
                this.vy = 0;
                this.age = 0;
                this.life = Math.random() * 0.8 + 0.2;
                this.hasSplit = false;
                this.isSplitParticle = false; // Reset split particle status
                this.isDeathSplit = false; // Reset death split status
                this.deathSplitGeneration = 0; // Reset to original generation
                this.canSecondSplit = false; // Reset special split ability
                this.birthWave = currentWave;
            }
            
            draw() {
                // Only draw death split particles (blue ones)
                if (!this.isDeathSplit) {
                    return; // Don't draw normal particles or red split particles
                }
                
                const ageRatio = Math.min(this.age / MAX_AGE, 1);
                const lifeRatio = Math.max(0, this.life);
                
                // Death split particles are bright blue
                const r = Math.floor(20 * (1 - ageRatio * 0.5));  // Very little red
                const g = Math.floor(100 * (1 - ageRatio * 0.3)); // Some green for blue tone
                const b = Math.floor(255 * (1 - ageRatio * 0.3)); // Bright blue
                
                // Size varies with life
                const currentSize = this.size * lifeRatio;
                
                // Opacity based on life only
                const alpha = lifeRatio;
                
                if (currentSize > 0.1 && alpha > 0.01) {
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, currentSize, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                }
            }
        }
        
        function initParticles() {
            particles = [];
            generateSpawnLines();
            
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const randomLine = spawnLines[Math.floor(Math.random() * spawnLines.length)];
                const particle = new Particle(randomLine);
                
                // Spread particles along their flow path
                const spreadFactor = Math.random();
                particle.age = Math.floor(spreadFactor * MAX_AGE * 0.6);
                
                // Simulate some flow movement for initial spread
                for (let j = 0; j < particle.age; j++) {
                    const t = j * 0.01;
                    const nx = particle.x * NOISE_SCALE;
                    const ny = particle.y * NOISE_SCALE;
                    const flowX = (noise(nx + 300, ny + 500, t) * 2 - 1) * FLOW_STRENGTH * 0.1;
                    const flowY = (noise(nx + 100, ny + 300, t) * 2 - 1) * FLOW_STRENGTH * 0.1;
                    particle.x += flowX;
                    particle.y += flowY + particle.line.direction * 0.03;
                }
                
                particles.push(particle);
            }
            
            // Pre-advance 90 frames so blue (death split) particles are visible immediately
            for (let f = 0; f < 90; f++) {
                time++;
                particles.forEach(particle => particle.update());
            }
        }
        
        function animate() {
            if (!isPaused) {
                time++;
                
                // Auto-regenerate lines every 15 seconds (20 times rapidly)
                if (time - lastLineGeneration >= lineGenerationInterval) {
                    currentWave++;
                    // Remove particles that have been present for 2 waves
                    particles = particles.filter(p => (currentWave - p.birthWave) < 2);
                    // Generate new lines 20 times in rapid succession
                    for (let i = 0; i < 20; i++) {
                        setTimeout(() => {
                            generateSpawnLines();
                            // Reset to base particle count and respawn
                            particles = particles.slice(0, PARTICLE_COUNT);
                            particles.forEach(particle => particle.respawn());
                        }, i * 100); // 100ms apart = 2 seconds total
                    }
                    lastLineGeneration = time;
                }
                
                // Clear canvas with subtle trail effect that fades after ~3 seconds
                // Using alpha 0.017 means trails fade to ~1% after 3 seconds (0.983^180 â‰ˆ 0.01)
                ctx.fillStyle = 'rgba(17, 17, 17, 0.017)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Update and draw particles
                particles.forEach(particle => {
                    particle.update();
                    particle.draw();
                });
                
                // Draw spawn line indicators (black vertical lines)
                ctx.globalAlpha = 0.1;
                spawnLines.forEach(line => {
                    ctx.strokeStyle = 'rgb(0, 0, 0)'; // All lines are black
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    // Draw full height vertical lines
                    ctx.moveTo(line.x, 0);
                    ctx.lineTo(line.x, canvas.height);
                    ctx.stroke();
                });
                ctx.globalAlpha = 1;
            }
            
            requestAnimationFrame(animate);
        }
        
        function resetParticles() {
            initParticles();
        }
        
        function regenerateLines() {
            generateSpawnLines();
            // Reset particles to base count and reassign to new lines
            particles = particles.slice(0, PARTICLE_COUNT); // Keep only base count
            particles.forEach(particle => particle.respawn());
        }
        
        function togglePause() {
            isPaused = !isPaused;
            const btn = document.getElementById('pauseBtn');
            if (btn) btn.textContent = isPaused ? 'Resume' : 'Pause';
        }
        
        // Resize canvas to maintain aspect ratio
        function resizeCanvas() {
            const aspectRatio = 16 / 9;
            const maxWidth = window.innerWidth * 0.95;
            const maxHeight = window.innerHeight * 0.9;
            
            let width = maxWidth;
            let height = width / aspectRatio;
            
            if (height > maxHeight) {
                height = maxHeight;
                width = height * aspectRatio;
            }
            
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
        }
        
        // Mouse tracking for splitting
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            mouse.x = (e.clientX - rect.left) * scaleX;
            mouse.y = (e.clientY - rect.top) * scaleY;
        });
        
        canvas.addEventListener('mouseenter', () => {
            mouse.isHovering = true;
        });
        
        canvas.addEventListener('mouseleave', () => {
            mouse.isHovering = false;
        });
        
        // Initialize
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        initParticles();
        animate();
    </script>
</body>
</html>